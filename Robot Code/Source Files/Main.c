#pragma config(Sensor, in1,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    moGoPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    barPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    gyroscope,      sensorGyro)
#pragma config(Sensor, in5,    liftPot2,       sensorPotentiometer)
#pragma config(Sensor, dgtl4,  moGoLim,        sensorTouch)
#pragma config(Sensor, dgtl7,  lDriveQuad,     sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  rDriveQuad,     sensorQuadEncoder)
#pragma config(Motor,  port1,           barL,          tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           leftB,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           leftF,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           lLift,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           moGo,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           intake,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           rLift,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           rightB,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightF,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          barR,          tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Prevents recursive includes
#ifndef MAIN_H
#define MAIN_H

// All includes
#pragma platform(VEX2)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"
#include "Main Control.c"
#include "Variables.c"
#include "GyroLib.c"
#include "AutoStack.c"
#include "LCDCode.c"
#include "Autonomous.c"

task controller()
{
	while (true)
	{
		// Added toggles for all aspects of the robot so that they could be shut off one at a time
		// since they are no longer tasks (you can no longer "stopTask()")

		// Drive
		if (driveIsActive)
		{
			lDrivePwr = vexRT[Ch3];
			rDrivePwr = vexRT[Ch2];

			// Introduces deadzone
			if (abs(lDrivePwr) < 5)
				lDrivePwr = 0;
			else if (abs(rDrivePwr) < 5)
				rDrivePwr = 0;

			motor[leftB] = motor[leftF] = lDrivePwr;
			motor[rightB] = motor[rightF] = rDrivePwr;
		}

		// Mobile Goal
		if (moGoIsManual)
		{
			stopTask(moGoSet);

			if (moGoIsActive)
			{
				if (vexRT[Btn7U])
						mGoalPwr = 100;
				else if (vexRT[Btn7D])
				{
					if (SensorValue(moGoPot) < MOGO_UP - 300)
						mGoalPwr = -100;
					else if (SensorValue(moGoPot) < MOGO_UP)
						mGoalPwr = -40;
					else
						mGoalPwr = 0;
				}
				else
					mGoalPwr = 0;

				// Setting mobile goal motor power
				motor[moGo] = mGoalPwr;
			}
		}
		else
		{
			startTask(moGoSet);

			if (moGoIsActive)
			{
				if (vexRT[Btn7U])
					moGoIsUp = true;
				else if (vexRT[Btn7D] && cones < 9)
					moGoIsUp = false;
				else if (vexRT[Btn7D] && cones >= 9)
					place();
			}
		}

		// Lift
		if (liftIsActive)
		{
			int startLiftPwr = lLiftPwr;
			if(vexRT[Btn6U])
				lLiftPwr = rLiftPwr = (100 + startLiftPwr*3)/4;
			else if(vexRT[Btn6D])
				lLiftPwr = rLiftPwr = (-100 + startLiftPwr*3)/4;
			else
			{
				if(SensorValue(liftPot) > LIFT_MIN + 100)
					lLiftPwr = rLiftPwr = -2;
				else
					lLiftPwr = rLiftPwr = -10;
			}

			motor[lLift] = lLiftPwr;
			motor[rLift] = rLiftPwr;
		}

		// Four bar


		// Intake
		if (intakeIsActive)
		{
			if (vexRT[Btn7L])
			{
				intakePwr = -100;
				intakeIsHolding = false;
			}
			else if (vexRT[Btn7R])
			{
				intakePwr = 100;
				intakeIsHolding = true;
			}
			else if (intakeIsHolding)
				intakePwr = INTAKE_HOLD;
			else if (!intakeIsHolding)
				intakePwr = -10;

			motor[intake] = intakePwr;
		}

		if(vexRT[Btn8L])
		{
			if(vexRT(Btn5D))
			{
				cones--;
			}else
			{
				isFieldControl = !isFieldControl;
			}
			while(vexRT(Btn8L));

		}
		if(vexRT[Btn8R])
		{
			if(vexRT[Btn5D])
			{
				cones++;
			}
			else
			{
				barIsManual = !barIsManual;
			}
			while(vexRT(Btn8R));
		}
	}
}


// Pre-Auton
void pre_auton()
{

	bDisplayCompetitionStatusOnLcd = false;
	bStopTasksBetweenModes = true;

	// Initializes the cones arrays
	autoConeInitVals();

	gyroIsCalibrating = true;
	writeDebugStreamLine("%d", SensorValue[liftPot]);
	startTask(runLCD);
	SensorType[gyroscope] = sensorNone;
	wait1Msec(1000);
	SensorType[gyroscope] = sensorGyro;
	// Calibrates Gyroscope
	gyroSetPort(gyroscope);

	//Allow gyro to settle and then calibrate (Takes a total of around 3 seconds)
	delay(1100);
	gyroCalibrate();
	gyroIsCalibrating = false;
	pidInit(gyroPid, 2, 0, 0.15, 0, 1270);
}



// User Control
task usercontrol()
{

//	right(90);

	datalogClear();
	stopTask(runLCD);
	clearLCDLine(0);
	clearLCDLine(1);
	stopTask(lDrivePID);
	stopTask(rDrivePID);

	// Starting Tasks
	startTask(autoStack);
	startTask(controller);
//	startTask(robotControl);
	//startTask(stabilizeLift);
	bool x = false;
	int b1 = 0;

	while (!x)
	{
		if (barIsManual)
		{
			stopTask(barSet);

			if (barIsActive)
			{
				if (vexRT[Btn8U])
					barPwr = 100;
				else if (vexRT[Btn8D])
					barPwr = -100;
				else
					barPwr = 0;

				motor[barR] = motor[barL] = barPwr;
			}
		}
		else
		{
			startTask(barSet);
			if (barIsActive)
			{
				if (vexRT[Btn8U])
					barIsUp = true;
				else if (vexRT[Btn8D])
					barIsUp = false;
			}
		}
		b1 = SensorValue[liftPot];


		sleep(50);
		//int leftPot = SensorValue(liftPot);
		//int rightPot = SensorValue(liftPot2);
		//writeDebugStreamLine("%f %f", GyroGetAngle(), GyroAngleAbsGet());
	}
}

#endif
