#pragma config(Sensor, in1,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    moGoPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    barPot,         sensorPotentiometer)
#pragma config(Sensor, in4,    gyroscope,      sensorGyro)
#pragma config(Sensor, in5,    liftPot2,       sensorPotentiometer)
#pragma config(Sensor, dgtl4,  moGoLim,      sensorTouch)
#pragma config(Sensor, dgtl7,  lDriveQuad,     sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  rDriveQuad,     sensorQuadEncoder)
#pragma config(Motor,  port1,           barL,          tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftB,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           leftF,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           lLift,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           moGo,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           intake,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           rLift,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightB,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightF,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          barR,          tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Prevents recursive includes
#ifndef MAIN_H
#define MAIN_H

// All includes
#pragma platform(VEX2)
#pragma competitionControl(Competition)


#include "MainControl.c"
#include "Variables.c"
#include "GyroLib.c"
#include "AutoStack.c"
#include "LCDCode.c"
#include "Debug.c"
#include "AutonControl.c"
#include "Vex_Competition_Includes.c"
//#include "Autonomous.c"

int bat = nAvgBatteryLevel;


// 7.56 V - .7 w/o MOGO
// 7.8 V - .7 w MOGO
// 7.564 V - .75 w MOGO
// 7.387 V - .74 w MOGO

// Turn Functions
float p = 1.3;
float d = -.3;
void turnLeft(int degrees)
{

	int disp = GyroGetAngle();
	int prevError = 0;
	while(GyroGetAngle() - disp < degrees * 1)
	{
		int error = -((GyroGetAngle()-disp) - degrees*1);
		int der = error - prevError;

		{
			der *= d;
			motor[rightB] = motor[rightF] = -(((GyroGetAngle()-disp) - degrees*1)*p + der);
			motor[leftB] = motor[leftF] = ((GyroGetAngle()-disp) - degrees*1)*p + der;
			display(GyroGetAngle(), degrees, der, motor[leftB], motor[rightB], error, 0, 0);
		}
		prevError = error;
	}
	sleep(50);
	/*		motor[rightB] = motor[rightF] = 20;
			motor[leftB] = motor[leftF] =	-20;
	while(GyroGetAngle() - disp < degrees*.9);*/

			motor[rightB] = motor[rightF] = -10;
			motor[leftB] = motor[leftF] =	-10;
}

// 7.56
void turnLeft1(int degrees)
{
	while(GyroGetAngle() < degrees*.7)
	{
		motor[rightB] = motor[rightF] = -75*(GyroGetAngle() - degrees)/(degrees*.95)+10;
		motor[leftB] = motor[leftF] = 75*(GyroGetAngle() - degrees)/(degrees*.95)-10;

	}
		motor[rightB] = motor[rightF] = 10;
		motor[leftB] = motor[leftF] =	-10;
}


void turnLeft2(int degrees)
{
	while(GyroGetAngle() < degrees*.55)
	{
		motor[rightB] = motor[rightF] = -75*(GyroGetAngle() - degrees)/(degrees*.95)+10;
		motor[leftB] = motor[leftF] = 75*(GyroGetAngle() - degrees)/(degrees*.95)-10;

	}
		motor[rightB] = motor[rightF] = 10;
		motor[leftB] = motor[leftF] =	-10;
}

// 7.8
void turnLeft2MoGo(int degrees)
{
	while(GyroGetAngle() < degrees*.7)
	{
		motor[rightB] = motor[rightF] = -80*(GyroGetAngle() - degrees)/(degrees*.95)+10;
		motor[leftB] = motor[leftF] = 80*(GyroGetAngle() - degrees)/(degrees*.95)-10;

	}
		motor[rightB] = motor[rightF] = 10;
		motor[leftB] = motor[leftF] =	-10;
}

void turnLeft3MoGo(int degrees, float stopThres1)
{
	while(GyroGetAngle() < degrees*stopThres1)
	{
		motor[rightB] = motor[rightF] = -80*(GyroGetAngle() - degrees)/(degrees*.95)+10;
		motor[leftB] = motor[leftF] = 80*(GyroGetAngle() - degrees)/(degrees*.95)-10;

	}
		motor[rightB] = motor[rightF] = 10;
		motor[leftB] = motor[leftF] =	-10;
}

// Pre-Auton
void pre_auton()
{
	bDisplayCompetitionStatusOnLcd = false;
//	bStopTasksBetweenModes = false;

	// Initializes the cones arrays
	autoConeInitVals();

	gyroIsCalibrating = true;
	writeDebugStreamLine("%d", SensorValue[liftPot]);
	startTask(runLCD);

	// Calibrates Gyroscope
	GyroInit(in4);
	wait1Msec(1000);
	wait1Msec(2000);
	SensorFullCount[in4] = 3600 * 100;
	SensorScale[in4] = 130;
	gyroIsCalibrating = false;
}

task autonomous()
{
	startTask(mGoalAuton);
	while (moGoIsUp) {}
	forward(1250);
	forwardNonPID(100, 30);
	//startTask(mGoalAuton);
	//while(!moGoIsUp);
}
/*?    clearDebugStream();
    datalogClear();
    clearLCDLine(0);
    clearLCDLine(1);

		// writeDebugStreamLine("Gyro at: %d", GyroGetAngle());
		// sleep(3000);
		// writeDebugStreamLine("Gyro at: %d", GyroGetAngle());

    switch(autonCount)
    {
      case 0:
        matchAuton_BLUE_24();
        break;
      case 1:
        matchAuton_RED_24();
        break;
      case 2:
        matchAuton_BLUE_7();
      case 3:
        matchAuton_RED_7();
        break;
      case 4:
        matchAuton_RED_7();
        break;
      case 5:
        matchAuton_BLUE_7();
        break;
    }
}*/

// User Control
task usercontrol()
{
	// Clearing all output streams
	datalogClear();
	clearLCDLine(0);
	clearLCDLine(1);

	// Stopping all auton tasks
	//stopTask(lDrivePID);
	//stopTask(rDrivePID);
	//autoTune(900);
	//turnLeft3MoGo(900, .74);
	// Starting Tasks
	// startTask(stabilizeLift);
	// startTask(autoStack);
	startTask(controller);
	startTask(robotControl);
	// startTask(runLCD);
	//turnLeft2MoGo(900);
	while (true)
	{
		bat = nAvgBatteryLevel;
		//int leftPot = SensorValue(liftPot);
		//int rightPot = SensorValue(liftPot2);
		//writeDebugStreamLine("%f %f", GyroGetAngle(), GyroAngleAbsGet());
	}
}

#endif
